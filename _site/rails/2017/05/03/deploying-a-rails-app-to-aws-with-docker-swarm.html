<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Deploying a Rails app to AWS with Docker Swarm</title>
  <meta name="description" content="Historically I’ve deployed Rails apps via Vlad or Capistrano and, honestly, deployment is always one of the worst parts of Rails.  I decided recently that I ...">

  <link rel="stylesheet" href="/blog/css/main.css">
  <link rel="canonical" href="http://fuzzyblog.io//blog/rails/2017/05/03/deploying-a-rails-app-to-aws-with-docker-swarm.html">
  <link rel="alternate" type="application/rss+xml" title="FuzzyBlog" href="http://fuzzyblog.io//blog/feed.xml">
  
  <!-- favicons -->
  <!-- shout out to: http://www.favicon-generator.org/ --> 
  <link rel="apple-touch-icon" sizes="57x57" href="/blog/assets/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/blog/assets/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/blog/assets/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/assets/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/blog/assets/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/blog/assets/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/blog/assets/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/blog/assets/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/assets/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/blog/assets/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/blog/assets/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/assets/favicon-16x16.png">
  <link rel="manifest" href="/blog/assets/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/blog/assets/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <!-- end_favicons -->
  
  <!-- twitter specific head tags -->
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@fuzzygroup">
  <meta name="twitter:creator" content="@fuzzygroup">
  <meta name="twitter:title" content="Deploying a Rails app to AWS with Docker Swarm">

  
    <meta name="twitter:description"
      content="Historically I’ve deployed Rails apps via Vlad or Capistrano and, honestly, deployment is always one of the worst parts of Rails.  I decided recently that I was just plain tired of classical deploy...">
  

  
    <meta name="twitter:image"
      content="http://fuzzyblog.io/blog/assets/scott_johnson.jpg">
  
  
  
  
  
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-83931583-1', 'auto');
    ga('send', 'pageview');

  </script>
  
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/blog/">FuzzyBlog</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/blog/about/">About</a>
          
        
          
          <a class="page-link" href="/blog/aws.html">AWS</a>
          
        
          
          <a class="page-link" href="/blog/category.html">Category</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/blog/resume.html">Resume for J. Scott Johnson</a>
          
        
          
          <a class="page-link" href="/blog/tag.html">Tag</a>
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Deploying a Rails app to AWS with Docker Swarm</h1>
    <p class="I'll"><time datetime="2017-05-03T19:32:30-04:00" itemprop="datePublished">May 3, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Historically I’ve deployed Rails apps via Vlad or Capistrano and, honestly, deployment is always one of the <strong>worst</strong> parts of Rails.  I decided recently that I was just plain tired of classical deployment and I wanted to move to deploying via the new Docker Swarm.  I’m in an interesting position where I need to launching N things over the next few months and thought of struggling with Capistrano every time I want to make something publicly available is, honestly, more than I can bear.  I’m looking at Docker and Docker Swarm from the perspective of there <strong>has</strong> to be a better way.</p>

<h1 id="application-description">Application Description</h1>

<p>In order to teach myself this new style of deployment, I didn’t want to use a toy application.  I wanted a real app that served a real purpose so I came up with the idea of a web app which evaluates a gem from GitHub and answers the question of “Should I (use this) Gem?”.  I call it <a href="http://www.shouldigem.com/">ShouldIGem</a> and it is live on the web in a minimal state.</p>

<p>This would give me a:</p>

<ul>
  <li>rails app</li>
  <li>that uses network i/o</li>
  <li>exercises a code base I’ve been building to illustrate possible issues</li>
  <li>uses multiple AWS resources in a scalable way - micro instances and RDS</li>
  <li>that uses Puma as a an application server</li>
  <li>separates the different functional parts of a Rails app into different “containers” i.e. web, sidekiq, migrations, redis</li>
</ul>

<p>Even though most applications of Docker seem to use a CI server, I wanted to do this at least quasi manually so I had a better understanding of what’s actually happening under the hood.  By the end I mildly regretted not using a CI server but I suspect the effort to setup a CI server would have been similar and I would have learned far less.</p>

<p>Surprisingly I didn’t actually have to do all that much development to pull this off.  Over the past several months, ever since I left my full time gig, I’ve been developing an HTML micro expression parsing engine and this is simply an application of it.</p>

<p>I call this application <em>Should I Gem</em> and it is online at <a href="http://www.shouldigem.com/">http://www.shouldigem.com/</a>.</p>

<h1 id="thank-you">Thank You</h1>

<p>A good friend is Nick Janetakis who is a Docker Captain and has taught over 10,000 people how to use Docker.  His latest course is <a href="https://diveintodocker.com/courses/dive-into-docker">Dive Into Docker</a>.  He pitched in on this and while I’m the humble scribe here, he’s been the steadfast advocate for Docker, pushing me towards it for almost a year now.  Thanks Nick – I couldn’t have done it without you.  Additional thank yous related to this project can be found on the <a href="http://www.shouldigem.com/pages/about">About Page</a>.</p>

<h1 id="things-to-understand">Things to Understand</h1>

<p>When you go into Docker Swarm, you’re not in the same old one server, one process Rails world you are likely used to.  You’re moving into a brave new world of zero downtime deploys and to support that, ideally, you need 2 of everything – 2 web instances, 2 sidekiq instances and so on.  This brings with it an increase in resource usage (mostly ram) so keep that in mind.</p>

<p><strong>Note</strong>: Since this is all being paid for on my own dime, I initially put this up on a single machine; no matter, changing it to multiple machines with Docker Swarm is actually trivial.</p>

<h1 id="getting-your-application-deployed-under-docker-swarm">Getting Your Application Deployed Under Docker Swarm</h1>

<h2 id="step-1-create-an-aws-rds-instance-for-the-database">Step 1: Create an AWS RDS Instance for the Database</h2>

<p>The very first thing I did to get started was to decide that I wanted my persistent storage absolutely separate from Docker.  Yes I do know that Docker’s volume support makes this less absolutely necessary than it once was but I’m pretty old school when it comes to the data side of the equation so I used AWS RDS.</p>

<p>To do this, I used the standard AWS RDS web front end and then copied the configuration parameters to database.yml.  Yes I could have used environment variables or secrets or something else but database.yml is just fine for a private app where there is only one developer.</p>

<p><strong>Note</strong>: Now that I’ve thought this over a bit, I understand more why in the Docker world, there is such a focus on environment variables versus static values checked into version control.  Historically I’ve always worked in terms of full time staff but in the brave new world of contract developers and freelancers, it does make sense to pull configuration away from people (particularly true with credentials like AWS api keys which can be so easily exploited if they escape into the wild).</p>

<h2 id="step-2-build-an-aws-instance-for-the-server">Step 2: Build an AWS Instance for the Server</h2>

<p>When you start talking about containers and cloud stuff, you often lose sight of the fact that there still are <strong>physical servers</strong> involved and you’re going to need one to run your containers on.  Thinking of containers as <em>a runtime layer for a software stack</em> is what finally make me understand them well enough to commit to using containers in production.</p>

<p>All I did here is build a t2.micro instance, nothing special at all.</p>

<h2 id="step-3-make-an-aws-security-group-and-set-up-aws-billing-alerts">Step 3: Make an AWS Security Group and Set Up AWS Billing Alerts</h2>

<p>Add your AWS instance to the same security group that was automatically created for your RDS instance.  Personally I’d recommend opening up the ICMP port for ping but that’s just me.</p>

<p>If you don’t normally setup AWS Billing Alerts on your cloud stuff then I highly recommend it. AWS entirely lacks the concept of a hosting budget for experimental stuff like this but AWS will alert you when your spending goes over limits so that’s at least something.</p>

<h2 id="step-4-install-docker-locally-on-your-development-box">Step 4: Install Docker Locally on Your Development box</h2>

<p>If you don’t have Docker installed locally then you need to do this now.  These days this is so simple that I don’t think you need any more help than <a href="http://www.docker.com/">http://www.docker.com/</a>.</p>

<h2 id="step-5-sign-up-for-dockerhub">Step 5: Sign up for DockerHub</h2>

<p>A key decision in any Docker strategy is where are your Docker Images stored.  This is called a <em>container registry</em> and think of it as a git repo but for a <strong>compiled</strong> artifact instead of source code.  AWS has their own registry called the AWS ECR (elastic container registry) but I decided to use Docker Hub instead.  The reason was that I figured that:</p>

<ul>
  <li>Docker Swarm would naturally work better with something from Docker.</li>
  <li>There are also issues with the AWS ECR and authentication needing to re-authenticate every 12 hours or so that I just plain didn’t want to tackle.</li>
</ul>

<h3 id="steps">Steps:</h3>

<ol>
  <li>Goto https://hub.docker.com/</li>
  <li>Create an account.</li>
  <li>Sign up for a paid account if you need more than one container (and you likely will).  It is only $7 per account for a micro account so it isn’t much money.</li>
  <li>Create repositories for each of your containers.  Please note that since you haven’t set them up yet you may need to wait until later in the process on this.</li>
</ol>

<h3 id="review">Review</h3>

<p>While I found DockerHub to be a bit pricey for what you get, it worked <strong>perfectly</strong>.  I don’t think that I hit a single snag related to the container registry and that’s just plain awesome.  Recommended!</p>

<h2 id="step-6-install-docker-on-your-aws-instance">Step 6: Install Docker on Your AWS Instance</h2>

<p>Although Amazon offers an Amazon branded version of Linux complete with Docker, Ubuntu has been very, very good to me over the years so when I created my instance, I used Ubuntu which means I needed to manually install docker per the Linux Install instructions:</p>

<p><a href="https://docs.docker.com/engine/installation/linux/ubuntu/#install-from-a-package">1</a> and <a href="https://docs.docker.com/engine/installation/linux/linux-postinstall/#kernel-compatibility">2</a>.</p>

<p>Here’s what you need to do once you are SSH’d into your Linux box:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sudo apt-get install     apt-transport-https     ca-certificates     curl     software-properties-common
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository    "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
    $(lsb_release -cs) \
    stable"
sudo apt-get install docker-ce
sudo docker run hello-world
sudo groupadd docker
sudo usermod -aG docker $USER
docker run hello-world
exit
sudo systemctl enable docker
docker login
</code></pre>
</div>

<p>Enter your login credentials for Docker Hub when you type docker login and they will be saved, securely, to  this file:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>~/.docker/config.json
</code></pre>
</div>

<p>After you get Docker installed on your AWS instance, there are two final steps:</p>

<ol>
  <li>Create a directory where your application will live.  I called mine should_i_gem but yours will obviously be different so I have ~/should_i_gem as my path.</li>
  <li>You need to initialize swarm mode as it is turned off by default.  Do this with:</li>
</ol>

<blockquote>
  <p>docker swarm init</p>
</blockquote>

<p>At the end of your docker swarm init command, you will get a message like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Swarm initialized: current node (zv7y6c7236mtjl4jv31kw1elb) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-4vpwpu2qiwkj7c5br92g8x8kchynw7evto5xm7n0fj46fj7e51-1yzi6jj84m19e9wylz7wvg55q \
    172.31.9.129:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.
</code></pre>
</div>

<p>This message is actually pretty important so make a note of it.  Personally all my Rails apps have a top level directory called docs where I can drop anything I need to ever come back to.  That’s a best practive that I’d recommend.</p>

<h2 id="step-7-get-your-application-ready-for-docker-ie-dockerizing-it">Step 7: Get Your Application Ready for Docker i.e. “Dockerizing It”</h2>

<p>The next step is to get your Rails application ready for Docker.  There are different ways to do this.  If you’re starting with a brand new app then I’d recommend that you use the <a href="https://github.com/nickjj/orats">ORATS</a> gem as a generator since that builds all the Docker stuff for you but I’ll take you through the steps manually.</p>

<h3 id="the-files-you-need">The Files You Need</h3>

<p>You need:</p>

<ul>
  <li>Dockerfile</li>
  <li>.dockerignore</li>
  <li>docker-compose.yml</li>
  <li>docker-compose.production.yml</li>
  <li>.env</li>
  <li>.env.production</li>
</ul>

<p>All of these files live in the root directory of your Rails app.  You’ll also likely need to change puma.rb in config.  Each of these files is described below.</p>

<h4 id="dockerfile">Dockerfile</h4>

<p>The Dockerfile tells Docker itself how to get it to build and how to run it.  Here’s what mine looked like:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>FROM ruby:2.3.1-alpine

RUN apk update &amp;&amp; apk add build-base nodejs mariadb-dev tzdata

RUN mkdir /app
WORKDIR /app

COPY Gemfile Gemfile.lock ./
RUN bundle install --binstubs

COPY . .

# The ENV variables simply need to be set for Rails to correctly pre-compile
# your assets. They do not need to be populated by real values.
RUN bundle exec rake RAILS_ENV=production DATABASE_URL=mysql2://user:pass@127.0.0.1/dbname SECRET_TOKEN=dummytoken assets:precompile

CMD puma -C config/puma.rb
</code></pre>
</div>

<p>The FROM directive tells Docker what “software engine” to use.  In this case I’m using a Ruby 2.3.1 language implementation on top of the Alpine linux distro which is a tiny Linux just for containers.</p>

<p>The first RUN command tells it to update and then build the best, nodejs and mariadb-dev and tzdata.  These are equivalent to doing a apt-get install on any Ubuntu system.</p>

<p>The second RUN command makes a directory /app and then it is set as WORKDIR.  Please note that all these commands generally execute from where your Dockerfile is located.</p>

<p>The first COPY command copies in Gemfile and Gemfile.lock and then runs bundler so that your gems are build in the runtime container.</p>

<p>The second COPY command copies your code into the container.</p>

<p>THE RUN bundle exec command sets up environment variables and handles asset compilation.</p>

<p>And then CMD puma starts the web process.</p>

<h4 id="dockerignore">.dockerignore</h4>

<p>The .dockerignore file tells Docker what files to ignore.  For example .git shouldn’t ever be pushed to DockerHub and neither should tmp.  Generally speaking you want your Docker images to be as slim as possible since the larger they are, they longer they take to download.</p>

<p>Here’s my .dockerignore:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>.git/
.dockerignore
.byebug_history
tmp/*
log/*
</code></pre>
</div>

<p>We do want the tmp and log directories to exist in the runtime for our application so we exclude them as tmp/* so the files within them are excluded but not the directory.</p>

<h4 id="docker-composeyml">docker-compose.yml</h4>

<p>The docker-compose.yml tells Docker how to run all the different containers in your application.  If you think about a normal web application, even on a single server, there are actually different pieces like:</p>

<ul>
  <li>web server</li>
  <li>database server</li>
  <li>sidekiq</li>
  <li>redis</li>
</ul>

<p>Here’s my docker-compose.yml:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>version: '3.1'

services:
  redis:
    image: 'redis:3.2-alpine'
    ports:
      - '6379'
    volumes:
      - 'redis:/var/lib/redis/data'

  web:
    depends_on:
      - 'redis'
    build: .
    env_file:
      - '.env'
    ports:
      - '3500:3500'
    volumes:
      - '.:/app'
  
  sidekiq: 
    depends_on: 
      - 'web'
    build: .
    env_file:
      - '.env'

    volumes:
      - '.:/app'
    command: "bundle exec sidekiq -C config/sidekiq.yml.erb"
  
volumes:
  redis: {}
  assets: {}
</code></pre>
</div>

<p>There are a few different directives here:</p>

<ul>
  <li>version - this tells Docker what version you want to run and since we want to use Swarm, it needs to be 3 or later.  I want the latest and that’s 3.1.</li>
  <li>services - this is the top level grouping of each of the containers you’re going to create.</li>
  <li>volumes - this exposes data from service to service.</li>
</ul>

<p>The key thing here is the services so let’s start by looking at our Redis service:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>redis:
  image: 'redis:3.2-alpine'
  ports:
    - '6379'
  volumes:
    - 'redis:/var/lib/redis/data'
</code></pre>
</div>

<p>What this is telling us is:</p>

<ul>
  <li>name the service redis</li>
  <li>base this on an image i.e. something from a repository (often DockerHub but not always); you find available images at <a href="http://www.dockerhub.com">DockerHub</a> and there are thousands upon thousands of images</li>
  <li>expose the port 6379 to other services</li>
  <li>store your data at the specified volume location</li>
</ul>

<p>Our web service now starts to show how this all fits together:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>web:
  depends_on:
    - 'redis'
  build: .
  env_file:
    - '.env'
  ports:
    - '3500:3500'
  volumes:
    - '.:/app'
</code></pre>
</div>

<p>What this is telling us is:</p>

<ul>
  <li>web depends on Redis actually running</li>
  <li>build the code from the current directory i.e. .</li>
  <li>use the environment file .env</li>
  <li>run on the port 3500 both internally to the service and external in the local environment</li>
  <li>expose a volume at app</li>
</ul>

<p>Now the sidekiq service brings it all home:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sidekiq: 
  depends_on: 
    - 'web'
  build: .
  env_file:
    - '.env'

  volumes:
    - '.:/app'
  command: "bundle exec sidekiq -C config/sidekiq.yml.erb"
</code></pre>
</div>

<p>What this is telling us is:</p>

<ul>
  <li>sidekiq depends on web</li>
  <li>it is again going to build from the current directory</li>
  <li>it will use the same env file and volumes</li>
  <li>it will use a special command to run sidekiq when the container starts up</li>
</ul>

<p>If you look at this sidekiq container it actually answers a common question that people have about Docker which is CRON based processing.  Let’s say you had a rake task that you wanted to run every day under Docker.  Just create a container which has an entry command of either cron or a scheduling gem like ClockWork and make it part of your stack.  Please bear in mind that if you’re launching multiple copies of your container then you’d need to allow for locking or whatever mechanism you needed to prevent concurrency issues.</p>

<h4 id="docker-composeproductionyml">docker-compose.production.yml</h4>

<p>Here is the <strong>production</strong> version of my docker-compose file that is the one that will be located on the server to define our services and our swarm:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>version: '3.1'

services:
  redis:
    image: 'redis:3.2-alpine'
    ports:
      - '6379'
    volumes:
      - 'redis:/var/lib/redis/data'
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure

  web:
    depends_on:
      - 'redis'
    image: fuzzygroup/shouldigem_web
    env_file:
      - '.env'
      - '.env.production'
    ports:
      - '80:80'
    deploy:
      replicas: 2
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure


  
  sidekiq: 
    depends_on: 
      - 'web'
    image: fuzzygroup/shouldigem_web
    env_file:
      - '.env'
      - '.env.production'      
    command: "bundle exec sidekiq -C config/sidekiq.yml.erb"
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure
volumes:
  redis: {}
</code></pre>
</div>

<h4 id="env">.env</h4>

<p>A .env file is a set of environment variables that Docker will cause to come into being in the environment that you are setting up.  Here’s my .env file:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>COMPOSE_PROJECT_NAME="should-i-gem"
BIND_ON=0.0.0.0:3500
RAILS_MAX_THREADS=1
WEB_CONCURRENCY=1
ACTIVE_JOB_URL=redis://redis:6379/0
REDIS_CACHE_URL=redis://redis:6379/0
ACTIVE_JOB_QUEUE_PREFIX=jobs
LOG_LEVEL=debug
RAILS_ENV=development
</code></pre>
</div>

<h4 id="envproduction">.env.production</h4>

<p>Here’s my .env.production:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>RAILS_MAX_THREADS=5
WEB_CONCURRENCY=5
RAILS_ENV=production
RAILS_SERVE_STATIC_FILES=true
BIND_ON=0.0.0.0:80
</code></pre>
</div>

<h2 id="step-8-build-your-app-under-docker">Step 8: Build Your App Under Docker</h2>

<p>Your Rails app is run inside a container or series of containers as defined by your compose file.  The key step to getting your containers to run is that they need to be “built”.  This is done with the docker-compose tool:</p>

<blockquote>
  <p>docker-compose build web</p>
</blockquote>

<h2 id="step-9-create-your-images-tag-them-and-push-them-to-docker-hub">Step 9: Create Your Images, Tag Them and Push them to Docker Hub</h2>

<p>Once you have built your docker images, they need to be pushed to the DockerHub where they can be pulled onto your server when you are ready to run them.  This is done with a command like this:</p>

<blockquote>
  <p>docker tag shouldigem_web fuzzygroup/shouldigem_web:latest</p>
</blockquote>

<h2 id="step-10-copy-the-docker-composeproductionyml-to-the-server">Step 10: Copy the docker-compose.production.yml to the Server</h2>

<p>In order to run your containers in production there are three files that need to go up to the server:</p>

<ul>
  <li>.env</li>
  <li>.env.production</li>
  <li>.docker-compose.production.yml</li>
</ul>

<p>Technically these files only need to be copied up <strong>once</strong> but because configurations change, I’d recommend that you think of these as <em>deployment artifacts</em> that need to be copied up every time.  And because these things are external to your actual image they can’t be a part of them.</p>

<h2 id="step-11-actually-deploying">Step 11: Actually Deploying</h2>

<p>Deployment of a Rails app under Docker, the way I’ve done it, is actually a two step process:</p>

<ol>
  <li>Copy the three files in Step 10 to the server or servers (if you have N servers then they need to go up to all N servers).</li>
  <li>Restart the Docker Swarm engine.</li>
</ol>

<h3 id="a-tiny-bash-deployer-to-get-your-files-up">A Tiny Bash Deployer to Get Your Files Up</h3>

<p>Steps 8, 9 and 10 can all be rolled together into a simple bash script as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c">#</span>
<span class="c"># The Docker Specific Stuff</span>
<span class="c">#</span>
docker-compose build web
docker tag shouldigem_web fuzzygroup/shouldigem_web:latest
docker push fuzzygroup/shouldigem_web:latest

<span class="c">#</span>
<span class="c"># Setting up the remote box</span>
<span class="c">#</span>
scp -i ~/.ssh/fuzzygroup2.pem .env  ubuntu@shouldigem.com:~/shouldigem
scp -i ~/.ssh/fuzzygroup2.pem .env.production  ubuntu@shouldigem.com:~/shouldigem
scp -i ~/.ssh/fuzzygroup2.pem docker-compose.production.yml ubuntu@shouldigem.com:~/shouldigem
</code></pre>
</div>

<h3 id="restarting-docker-swarm">Restarting Docker Swarm</h3>

<p>Here’s the command to restart Docker Swarm:</p>

<blockquote>
  <p>docker stack deploy -c docker-compose.production.yml –with-registry-auth shouldigem</p>
</blockquote>

<p>This has to be done after:</p>

<ul>
  <li>Your images have been built and pushed to Docker Hub</li>
  <li>The .env and compose files are copied to all remote servers</li>
</ul>

<h3 id="two-discrete-steps-sucks-monkey-chunks">Two Discrete Steps Sucks Monkey Chunks</h3>

<p>Yes I’m clearly aware that two separate steps for deployment (and that this entirely ignores migrations) actually sucks monkey chunks.  I’ll roll all this into an Ansible deployer in the not too distant future.  And I’ll address migrations at that time.</p>

<h1 id="gotchas">Gotchas</h1>

<p>In getting this deployed, I only hit one real gotcha – I wanted to use Nginx to serve the 10 or so static assets (images, JS and CSS) that make up this application.  Due to the layers of isolation and the fact that Docker Swarm prevents use of the VOLUMES_FROM directive, I was simply unable to make this work.  There are various workarounds but none of them let me achieve my zero downtime goal so I ended up just using Puma to serve them for now.  At some point I’m sure that I or someone else will figure this out.</p>

<h1 id="conclusions-and-observations">Conclusions and Observations</h1>

<p>If you’re going to go down the container route then I strongly recommend that if at all possible, you do it with someone who has already done it.  Docker Swarm and Docker itself are highly impressive technologies but the levels of abstraction and isolation that you have to internalize are very hard to wrap your head around.</p>

<p>You should be aware that there’s a whole additional post that I need to write – <em>Working with a Rails App Under Docker</em> which discusses how you work with a Rails app under Docker and will cover things like logs, migrations, getting into console and so on.  Look for that in the next few days.</p>

<h1 id="recommended-reading">Recommended Reading</h1>

<p>Here are some good things to read</p>

<ul>
  <li><a href="http://www.diveintodocker.com">Dive Into Docker</a></li>
  <li><a href="https://jbhannah.net/articles/rails-development-with-docker/">J Hannah</a></li>
  <li><a href="https://leanpub.com/the-devops-2-1-toolkit">Devops 2.1 Toolkit</a></li>
  <li><a href="https://diveintodocker.com/blog/comparing-virtual-machines-vs-docker-containers">Containers versus Virtual machines</a></li>
</ul>


  </div>
  
  

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">FuzzyBlog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>FuzzyBlog</li>
          <li><a href="mailto:fuzzygroup@gmail.com">fuzzygroup@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/fuzzygroup"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">fuzzygroup</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/fuzzygroup"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">fuzzygroup</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Scott Johnson writing about the usual array of nerd stuff: AWS / Ansible / Ruby / Rails / Elixir / Misc / Hyde.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
